---
title: Клетчатое поле
description: «У меня все ходы записаны»
published: true
---
## Теория

Для управления данными в программировании очень удобно использовать таблички. Например, как спланировать карту игрового уровня, если в игре используется клетчатое поле?

Вот такое:

![kletkopole.png]({{site.baseurl}}/lessons/processing/kletkopole.png)

Можно записать табличку текстом и пометить чёрный 1, а белый 0:

![tablechsisla.png]({{site.baseurl}}/lessons/processing/tablechsisla.png)

А можно наоборот. А можно вообще вписать туда «чёрный» и «белый» — как удобно.

Допустим, с табличкой понятно. А как табличку описать на языке программирования  Python? И сделать, чтобы Processing, например, читал эту табличку и рисовал уровень по ней? Очень просто! Запишем каждый ряд, как список. А потом соберём эти списки в ещё один списко! Список списков! Можно вот так:

```python
pole = [[0,1,1,1,1],  [0,0,0,0,0],  [1,1,1,1,0],  [0,0,0,0,0]]
```

А можно список записать и в несколько строчек, как ниже. Тогда pole[1][2] — это означает, что нужно взять список под индексом 1(pole[1] — второй), а в нём элемент под индексом 2, то есть 3й. Он равен 0. То есть pole[1][2] подставит вместо себя 0. А вот как это можно отрисовать:

```python
#Зададим список списков, можно для наглядности
#в несколько строчек
pole = [[0,1,1,1,1],
        [0,0,0,0,0],
        [1,1,1,1,0],
        [0,0,0,0,0]]


#Посчитаем и запомним, сколько рядов и столбцов
numRyad = len(pole) # длина списка списков,
numStolbets = len(pole[0]) # длина первого списка в списке
def setup():
    size(600,400)
    
def draw():
    
    global finRyad, finStolbets
    for nRyada in range(numRyad): # берём каждый ряд
        # в нём каждый столбец
        for nStolbtsa in range(numStolbets):
            # если 1 красим в чёрный иначе в белый
            if pole[nRyada][nStolbtsa] == 1:
                fill(0)
            else:
                fill(255)
            #рисуем клеточку
            rect(nStolbtsa*30,nRyada*30,30,30)

```

## Задание

1. Напиши скетч, по которому Processing построит клетчатое поле с чётным количеством столбцов и полей. Есть двумерный список цветов этих полей, каждый элемент — название цвета. Раскрасить клетчатое поле в зависимости от того, какие цвета(можешь заменить на числа) вписаны в двумерный список.
2. Напиши скетч, по которому Processing построит клетчатое поле, клетки белого цвета. Есть таблица цветов поля (список списков), изначально все его значения «белый». При клике по клеточке в таблицу нужно записать по этим ряду и столбцу слово «чёрный». После этого цвет меняется на чёрный. Если снова нажать на клетку — она меняет цвет обратно на белый, и в таблицу записывается «белый».
4. Напиши скетч, в котором по клетчатому полю будет ходить какая-то фигура (эллипс и т.д.). Управление — стрелочками (проследи, чтобы фигура не выходила за пределы поля). При нажатии на пробел она начинает оставлять за собой след, меняя цвет тех клеток, в которых оказалась. При повторном нажатии на пробел режим закрашивания клеток отключается
5. Добавь к предыдущему проекту возможность выбирать цвета закрашивания и  режимы очистки, чтобы можно было убирать «след». Один режим — «включить стирание», все клетки, через который проходит кружок, очищаются, пока режим стирания не стирается. Другой режим — при нажатии клавиши стирается только та клетка, в которой находится кружок. Добавь отображение информации о режимах на холст.
6. Свой проект с полем, запоминающим изменения.

## Команды и т.д.

- **rectMode(CENTER)** — рисовать прямоугольник «от центра»
- **tasks= \[“побрить руку”,”скукожиться”,”купить поп-сокет”\]** — список дел(строк)
- **tasks= \[\[1,0,1,1],\[1,0,1,1],\[1,0,1,1]]** — список списков чисел
- **tasks[2][1] = 5** — теперь элемент списка списков с индексами 2 и 1 равен 5
- **len(tasks)** — количество элементов списка
- **del tasks[0]** — удалить начальный элемент списка
- **del tasks[len(tasks)-1]** — удалить последний элемент списка
- **for element in tasks:** — для каждого элемента списка…
- **for nRyada in range(len(pole)):**
- __**for nStrobtsa in range(len(pole[nRyada ] ):**
- ____**rect(nStrobtsa 30, nRyada 30,    30,30)**
- **for step in range(9):** — повторить 9 раз
- **myText = myText + “1”** — прибавить к тексту в переменной «1» справа
- **keyPressed** — нажата ли клавиша? Содержит True или False
- **key** — переменная, содержит символ нажатой клавиши
- **keyCode** —  если нажата ALT, CTRL, SHIFT или стрелка LEFT, RIGHT, UP, DOWN
- при этом в key записывается CODED
- **keyPressed() / keyReleased()** — когда клавиша нажата/когда клавиша отпущена
- **textAlign(CENTER,CENTER)** — выравнивание текста по центру
- **text(u”Привет”,200,300)** — вывести текст в 200 от левого края и 300 от правого края
- **mouseClicked():** — функция, код в ней один раз срабатывает при нажатии мыши
- **mouseX, mouseY, pmouseX, pmouseY** — координаты курсора мыши









